//***************************************************************************
// Licensed Materials - Property of IBM
//
// Governed under the terms of the International
// License Agreement for Non-Warranted Sample Code.
//
// (C) COPYRIGHT International Business Machines Corp. 1997 - 2006
// All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by Gsal ADP Schedule Contract with IBM Corp.
//***************************************************************************
//
// SOURCE FILE NAME: TbRowcompress.sqlj
//
// SAMPLE: How to perform row compression on a table
//
//         This sample shows:
//         1. How to enable the row compression after a table is created.
//         2. How to enable the row compression during table creation.
//         3. Usage of the options to REORG to use the exiting dictionary
//            or creating a new dictionary.
//         4. How to estimate the effectiveness of the compression.
//
//         This sample should be run using the following steps:
//         1.Compile the program with the following command:
//           javac TbRowcompress.java
//
//         2.The sample should be run using the following command
//           java TbRowcompress <path for dummy file>
//           The fenced user id must be able to create or overwrite files in
//           the directory specified.This directory must be a full path on
//           the server. The dummy file 'dummy.del' must
//           exist before the sample is run.
// 
// SQL STATEMENTS USED:
//         ALTER TABLE
//         COMMIT
//         CREATE TABLE
//         DROP TABLE
//         DELETE
//         EXPORT
//         FETCH
//         IMPORT
//         INSERT
//         INSPECT
//         REORG
//         RUNSTATS
//         SELECT
//         UPDATE
//
// JAVA 2 CLASSES USED:
//         Statement
//         CallableStatement
//         ResultSet
//
// Classes used from Util.java are:
//         Db
//         Data
//         JdbcException
//
// OUTPUT FILE: TbRowcompress.java (available in the online documentation)
//***************************************************************************
//
// For more information on the sample programs, see the README file.
//
// For information on developing JDBC applications, see the Application
// Development Guide.
//
// For information on using SQL statements, see the SQL Reference.
//
// For the latest information on programming, compiling, and running DB2
// applications, visit the DB2 application development website at
//     http://www.software.ibm.com/data/db2/udb/ad
//***************************************************************************

import java.lang.*;
import java.sql.*;
import sqlj.runtime.*;
import sqlj.runtime.ref.*;

#sql iterator TbRowcompress_Cursor0(String);
#sql iterator TbRowcompress_Cursor1(int, int);
#sql iterator TbRowcompress_Cursor2(int, int, int, int, int);

class TbRowcompress
{
  public static void main(String argv[])
  {
      try
      {
        Connection con;
        DefaultContext ctx;

        // initialize DB2Driver and establish database connection.
        COM.ibm.db2.jdbc.app.DB2Driver db2Driver =
          (COM.ibm.db2.jdbc.app.DB2Driver)
            Class.forName("COM.ibm.db2.jdbc.app.DB2Driver").newInstance();
        con = DriverManager.getConnection("jdbc:db2:SAMPLE");

        ctx = new DefaultContext( con );
        DefaultContext.setDefaultContext(ctx);

        String path = argv[0];

        System.out.println(
          "THIS SAMPLE SHOWS HOW TO PERFROM ROW COMPRESSION ON A TABLE.");

         // to Load table data into a file.
        getLoadData(con, path);

        // to enable row compression on table.
        enableRowCompressionForTables(con, path); 

        // to disable row compression on tables.
        disableRowCompressionForTables(con, path); 

        // to inspect the compression.
        inspectCompression(con, path); 

        // disconnect from the 'sample' database
        con.close();

      }
      catch (Exception e)
      {
        SqljException sqljExc = new SqljException(e);
        sqljExc.handle();
      }
    
  } // main

  // this function shows how to prepare data for load
  static void getLoadData(Connection con, String path) throws SQLException
  {
    try
    {
      System.out.println(
        "\n-----------------------------------------------------------" +
        "\nUSE THE SQL STATEMENTS:\n" +
        "  CREATE TABLE \n" +
        "TO CREATE A TABLE \n" +
        "\n    Perform:\n" +
        "    CREATE TABLE temp(empno INT, sal INT)");

      // create a temporary table
      #sql {CREATE TABLE temp(empno INT, sal INT)};
      #sql {COMMIT};

      // insert data into the table and export the data in order to obtain
      // dummy.del file in the required format for load.

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "TO INSERT DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO temp VALUES(100, 20000)\n" +
        "    INSERT INTO temp VALUES(200, 30000)\n" +
        "    INSERT INTO temp VALUES(100, 30500)\n" +
        "    INSERT INTO temp VALUES(300, 20000)\n" +
        "    INSERT INTO temp VALUES(400, 30000)");

      // insert data into the table
      #sql {INSERT INTO temp VALUES(100, 20000)};
      #sql {INSERT INTO temp VALUES(200, 30000)};
      #sql {INSERT INTO temp VALUES(100, 30500)};
      #sql {INSERT INTO temp VALUES(300, 20000)};
      #sql {INSERT INTO temp VALUES(400, 30000)};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  EXPORT \n" +
        "TO EXPORT TABLE DATA INTO A FILE \n" +
        "\n    Perform:\n" +
        "    EXPORT TO dummy.del OF DEL SELECT * FROM temp");

      // export data into a dummy file
      // call the stored procedure ADMIN_CMD for EXPORT
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      
      String str ="CALL SYSPROC.ADMIN_CMD" +
                  "('EXPORT TO " + 
                  path +
                  "dummy.del OF DEL SELECT * FROM temp')";

      Statement stmt = con.createStatement();
      stmt.executeUpdate(str);
      stmt.close();

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  DROP \n" +
        "TO DROP THE TABLE \n" +
        "\n    Perform:\n" +
        "    DROP TABLE temp");

      // drop the temporary table
      #sql {DROP TABLE temp};
      #sql {COMMIT};


    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // getLoadData

  // this function shows how to enable row compression for tables  
  static void enableRowCompressionForTables
                (Connection con, String path) throws SQLException
  {
    try
    {
      System.out.println(
        "\n-----------------------------------------------------------" +
        "\nUSE THE SQL STATEMENTS:\n" +
        "  CREATE TABLE \n" +
        "TO CREATE A TABLE \n" +
        "\n    Perform:\n" +
        "    CREATE TABLE empl(emp_no INT, salary INT)");

      // create a table without enabling row compression at the time of
      // table creation
      #sql {CREATE TABLE empl(emp_no INT, salary INT)};

      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  IMPORT \n" +
        "TO IMPORT THE DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    IMPORT FROM dummy.del OF DEL INSERT INTO empl");

      // import data from file
      // call the stored procedure ADMIN_CMD for IMPORT
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");

      String str ="CALL SYSPROC.ADMIN_CMD" +
                  "('IMPORT FROM " + 
                  path +
                  "dummy.del OF DEL INSERT INTO empl')";

      Statement stmt = con.createStatement();
      stmt.executeUpdate(str);
      stmt.close();

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  ALTER TABLE \n" +
        "TO ENABLE ROW COMPRESSION \n" +
        "\n    Perform:\n" +
        "    ALTER TABLE empl COMPRESS YES");

      // enable row compression
      #sql {ALTER TABLE empl COMPRESS YES};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  REORG \n" +
        "TO COMPRESS ROWS \n" +
        "\n    Perform:\n" +
        "    REORG TABLE empl");

      // perform non-inplace reorg to compress rows and to retain
      // existing dictionary
      // call the stored procedure ADMIN_CMD for REORG
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      #sql {CALL SYSPROC.ADMIN_CMD('REORG TABLE empl')};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  DROP \n" +
        "TO DROP THE TABLE \n" +
        "\n    Perform:\n" +
        "    DROP TABLE empl");
 
      // drop the temporary table
      #sql {DROP TABLE empl};
      #sql {COMMIT}; 

    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // enableRowCompressionForTables

  // this function shows how to disable rowcompression on table
  static void disableRowCompressionForTables
                (Connection con, String path) throws SQLException
  {
    try
    {
      System.out.println(
        "\n-----------------------------------------------------------" +
        "\nUSE THE SQL STATEMENTS:\n" +
        "  CREATE \n" +
        "TO CREATE A TABLE \n" +
        "\n    Perform:\n" +
        "    CREATE TABLE empl(emp_no INT, salary INT) COMPRESS YES");

      // create a table enabling compression initially
      #sql {CREATE TABLE empl(emp_no INT, salary INT) COMPRESS YES};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  IMPORT \n" +
        "TO IMPORT THE DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    IMPORT FROM dummy.del OF DEL INSERT INTO empl");
 
      // import data into the table
      // call the stored procedure ADMIN_CMD for IMPORT
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      String str ="CALL SYSPROC.ADMIN_CMD" +
                  "('IMPORT FROM " + 
                  path +
                  "dummy.del OF DEL INSERT INTO empl')";

      Statement stmt = con.createStatement();
      stmt.executeUpdate(str);
      stmt.close();

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  REORG \n" +
        "TO COMPRESS ROWS \n" +
        "\n    Perform:\n" +
        "    REORG TABLE empl");

      // perform reorg to compress rows
      // call the stored procedure ADMIN_CMD for REORG
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      #sql {CALL SYSPROC.ADMIN_CMD('REORG TABLE empl')};
      #sql {COMMIT};


      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "  UPDATE \n" +
        "  DELETE \n" +
        "TO INSERT, UPDATE OR DELETE DATA IN TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO empl VALUES(400, 30000)\n" +
        "    UPDATE empl SET salary = salary + 1000\n" +
        "    DELETE FROM empl WHERE emp_no = 200");

      // perform modifications on table
      #sql {INSERT INTO empl VALUES(400, 30000)};
      #sql {UPDATE empl SET salary = salary + 1000};
      #sql {DELETE FROM empl WHERE emp_no = 200};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  ALTER TABLE \n" +
        "TO DISABLE ROW COMPRESSION FOR THE TABLE \n" +
        "\n    Perform:\n" +
        "    ALTER TABLE empl COMPRESS NO");
 
      // disable row compression for the table
      #sql {ALTER TABLE empl COMPRESS NO};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  REORG TABLE \n" +
        "TO REORG THE TABLE AND REMOVE EXISTING DICTIONARY \n" +
        "\n    Perform:\n" +
        "    REORG TABLE empl RESETDICTIONARY");
 
      // Perform reorg to remove existing dictionary.
      // New dictionary will be created and all the rows processed
      // by the reorg are decompressed.
      // call the stored procedure ADMIN_CMD for REORG
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      #sql {CALL SYSPROC.ADMIN_CMD('REORG TABLE empl RESETDICTIONARY')};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  DROP \n" +
        "TO DROP THE TABLE \n" +
        "\n    Perform:\n" +
        "    DROP TABLE empl");

      // drop the table
      #sql {DROP TABLE empl};
      #sql {COMMIT};
     
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // disableRowCompressionForTables

  // this function demonstrates the extent of row compression for table
  static void inspectCompression(Connection con, String path) throws SQLException
  {
    try
    {
      System.out.println(
        "\n-----------------------------------------------------------" +
        "\nUSE THE SQL STATEMENTS:\n" +
        "  CREATE TABLE \n" +
        "TO CREATE A TABLE \n" +
        "\n    Perform:\n" +
        "    CREATE TABLE empl(emp_no INT, salary INT)");

      // create a table
      #sql {CREATE TABLE empl(emp_no INT, salary INT)};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  IMPORT \n" +
        "TO IMPORT DATA INTO TABLE \n" +
        "\n    Perform:\n" +
        "    IMPORT FROM dummy.del OF DEL INSERT INTO empl");

      // import data into the table
      // call the stored procedure ADMIN_CMD for IMPORT
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      String str ="CALL SYSPROC.ADMIN_CMD" +
                  "('IMPORT FROM " + 
                  path +
                  "dummy.del OF DEL INSERT INTO empl')";

      Statement stmt = con.createStatement();
      stmt.executeUpdate(str);
      stmt.close();

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  ALTER TABLE \n" +
        "TO ENABLE COMPRESSION \n" +
        "\n    Perform:\n" +
        "    ALTER TABLE empl COMPRESS YES");

      // enable row compression for the table
      #sql {ALTER TABLE empl COMPRESS YES};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "TO INSERT DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO empl VALUES(400, 30000)");
 
      // insert some data into the table
      #sql {INSERT INTO empl VALUES(400, 30000)};
      #sql {COMMIT};
 
      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSPECT \n" +
        "TO ESTIMATE THE EFFECTIVENESS OF COMPRESSION \n" +
        "\n    Perform:\n" +
        "    INSPECT ROWCOMPESTIMATE TABLE NAME empl RESULTS KEEP result");
 
      // Perform inspect to estimate the effectiveness of compression.
      // Inspect has to be run before the REORG utility.
      // Inspect allows you to look over tablespaces and tables for their
      // architectural integrity.
      // 'result' file contains percentage of bytes saved from compression,
      // Percentage of rows ineligible for compression due to small row size,
      // Compression dictionary size, Expansion dictionary size etc.
      // To view the contents of 'result' file perform
      //    db2inspf result result.out; This formats the 'result' file to
      // readable form.
 
      String execCmd = "db2 INSPECT ROWCOMPESTIMATE TABLE NAME empl" +
                       " RESULTS KEEP result";

      // execute the command
      Process p1 = Runtime.getRuntime().exec(execCmd);

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  REORG \n" +
        "TO REORG THE TABLE \n" +
        "\n    Perform:\n" +
        "    REORG TABLE empl");
 
      // perform reorg on the table
      // call the stored procedure ADMIN_CMD for REORG
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      #sql {CALL SYSPROC.ADMIN_CMD('REORG TABLE empl')};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "TO INSERT DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO empl VALUES(500, 40000)");
 
      // all the rows will be compressed including the one inserted
      // after reorg
      #sql {INSERT INTO empl VALUES(500, 40000)};
      #sql {COMMIT};
 
      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  ALTER TABLE \n" +
        "TO DISABLE THE COMPRESSION \n" +
        "\n    Perform:\n" +
        "    ALTER TABLE empl COMPRESS NO");

      // disable row compression for the table.
      // rows inserted after this will be non-compressed.
      #sql {ALTER TABLE empl COMPRESS NO};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "TO INSERT DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO empl VALUES(600, 40500)");

      // add one row of data to the table
      #sql {INSERT INTO empl VALUES(600, 40500)};
      #sql {COMMIT}; 

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  ALTER TABLE \n" +
        "TO ENABLE THE COMPRESSION \n" +
        "\n    Perform:\n" +
        "    ALTER TABLE empl COMPRESS YES");

      // enable the row compression for the table
      #sql {ALTER TABLE empl COMPRESS YES};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  INSERT \n" +
        "TO INSERT DATA INTO THE TABLE \n" +
        "\n    Perform:\n" +
        "    INSERT INTO empl VALUES(700, 40600)");

      // add one row of data to the table
      #sql {INSERT INTO empl VALUES(700, 40600)};
      #sql {COMMIT};

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  RUNSTATS \n" +
        "TO MEASURE THE EFFECTIVENESS OF COMPRESSION \n" +
        "\n    Perform:\n" +
        "    RUNSTATS ON TABLE EMPL");

      // Perform runstats to measure the effectiveness of compression using
      // compression related catalog fields. New columns will be updated to
      // catalog table after runstats if performed on a compressed table.
 
      // get fully qualified name of the table
      String tableName = "EMPL";
      String schemaName = getSchemaName(tableName);
      String fullTableName = schemaName + "." + tableName;

      // call the stored procedure ADMIN_CMD for RUNSTATS
      System.out.println();
      System.out.println("Call stored procedure named SYSPROC.ADMIN_CMD");
      str = "CALL SYSPROC.ADMIN_CMD('" + 
            "RUNSTATS ON TABLE " +
            fullTableName + 
            "')";

      Statement stmt1 = con.createStatement();
      stmt1.executeUpdate(str);
      stmt1.close();

      System.out.println();
      System.out.println("  SELECT * FROM empl");
      System.out.println(
        "    EMP_NO  SALARY\n" +
        "    ------  ------");
 
      int emp_no = 0;
      int sal = 0;

      TbRowcompress_Cursor1 cur1;

      // declare a cursor
      #sql cur1 = {SELECT * FROM empl};

      // fetch the cursor
      #sql {FETCH :cur1 INTO :emp_no, :sal};

      while (!cur1.endFetch())
      {
       System.out.println(
         "      " + Data.format(emp_no, 3) +
         "   " + Data.format(sal, 5));

        #sql {FETCH :cur1 INTO :emp_no, :sal};
      }

      // close the cursor
      cur1.close();

      System.out.println();
      System.out.println(
        "SELECT avgrowsize, avgcompressedrowsize, pctpagessaved,\n" +
        "       avgrowcompressionratio, pctrowscompressed\n" +
        "  FROM SYSCAT.TABLES WHERE tabname = 'EMPL'");
      System.out.println(
        "\n    AvRowSize AvCmprsdRowSize PerPgSaved AvgRowCmprRatio" +
        " PerRowsCmprsd\n" +
        "    --------- --------------- ---------- ---------------" +
        " -------------");

      int avgrowsize = 0;
      int avgcompressedrowsize = 0;
      int pctpagessaved = 0;
      int avgrowcompressionratio = 0;
      int pctrowscompressed = 0;

      TbRowcompress_Cursor2 cur2;

      // declare a cursor
      #sql cur2 = {SELECT avgrowsize, avgcompressedrowsize,
                          pctpagessaved, avgrowcompressionratio,
                          pctrowscompressed
                     FROM SYSCAT.TABLES 
                     WHERE tabname = 'EMPL'};

      // fetch the cursor
      #sql {FETCH :cur2 INTO :avgrowsize, :avgcompressedrowsize,
                             :pctpagessaved, :avgrowcompressionratio,
                             :pctrowscompressed};

      while (!cur2.endFetch())
      {
        System.out.println(
          "    " + Data.format(avgrowsize, 4) +
          "    " + Data.format(avgcompressedrowsize, 11) +
          "    " + Data.format(pctpagessaved, 9) +
          "    " + Data.format(avgrowcompressionratio, 9) +
          "    " + Data.format(pctrowscompressed, 13));

        #sql {FETCH :cur2 INTO :avgrowsize, :avgcompressedrowsize, 
                               :pctpagessaved, :avgrowcompressionratio,
                               :pctrowscompressed};
      }

      // close the cursor
      cur2.close();

      System.out.println(
        "\nUSE THE SQL STATEMENTS:\n" +
        "  DROP \n" +
        "TO DROP THE TABLE \n" +
        "\n    Perform:\n" +
        "    DROP TABLE empl");

      // drop the temporary table
      #sql {DROP TABLE empl};
      #sql {COMMIT};

    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // inspectCompression

  // function to get the schema name for a particular table
  static String getSchemaName(String tableName) throws Exception
  {
    // declare a cursor to run through the result of the query
    TbRowcompress_Cursor0 cur0;

    #sql cur0 = {SELECT tabschema FROM syscat.tables WHERE tabname = :tableName};

    String schemaName = null;
    #sql {FETCH :cur0 INTO :schemaName};

    // remove the trailing white space characters from schemaName before
    // returning it to the calling function
    return schemaName.trim();

  } // getSchemaName
}
