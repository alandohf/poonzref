/**
test volatile keyword 
http://zqwt.012.blog.163.com/blog/static/12044684201081831511245/

volatile 的英文解释是――“易失的，易改变的”。顾名思义，这个关键字的含义是向编译器指明变量的内容可能会由于编译器意想不到的情况的变化而发生变化。这个解释仍然比较抽象，感兴趣的可以继续阅读下面内容。
 
先看一下编译器对程序的优化过程是怎么进行的
如果编译器在代码中发现对同一地址的两次访问之间，没有对该地址进行写操作，那么编译器的优化过程认为――第一次寻址读取该地址时取得的变量的值（编译器会尽最大可能把这个值存放在通用寄存器R中或者cache中）作为第二次寻址的值，而并不是再做第二次内存的 I/O 寻址操作（当CPU把该变量的值放到通用寄存器或者cache中中后就不会再关心对应内存中的值）。
例如：
int i = 10;
int j = i;  // (1)语句
int k = i;  // (2)语句
因为在（1）、（2）两条语句中，i没有被用作左值（同一地址的两次访问之间，没有对该地址进行写操作），这时候编译器认为i的值没有发生变化，所以在（1）语句时，从内存中取出i的值赋给j之后，这个值并没有丢掉（存放在通用寄存器中），而是在（2）语句时继续用这个值给k赋值。编译器不会生成汇编代码而重新从内存里寻址i的值。
 
Volatile这个关键字的必要性（真正意义之所在）
但其他程序（例如内核程序或一个中断）修改了内存中该变量的值，此时寄存器R中的值并不会随之改变而更新，由于优化器的作用编译器仍然去利用之前存放在寄存器R中的值，而不去寻址内存中的值（但我们必须改变这个变量的值）。为了解决这种情况C语言就引入了volatile限定词，让代码在引用该变量时多费一点劲儿，再去内存中取出该变量的值。
例如：
Volatile int i = 10;
int j = i;  // (3)语句
int k = i; // (4)语句
         这里，volatile关键字告诉编译器i是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值，因而编译器生成的汇编代码会重新从内存中i的地址处读取i的值存放在k中。
一句话概括就是，当用volatile关键字修饰变量时，优化器在用到这个变量时必须每次都小心地去内存重新读取（关键之处）这个变量的值，而不是使用保存在寄存器R里的备份。

**/

#include <stdio.h>

int main(int argc,char *argv[]){

	
return 0;
}
