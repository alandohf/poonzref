//***************************************************************************
// Licensed Materials - Property of IBM
//
// Governed under the terms of the International
// License Agreement for Non-Warranted Sample Code.
//
// (C) COPYRIGHT International Business Machines Corp. 1997 - 2004
// All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//***************************************************************************
//
// SOURCE FILE NAME: TbAST.sqlj
//
// SAMPLE: How to use staging table for updating deferred AST 
//          
//         This sample:
//         1. Creates a refresh-deferred summary table 
//         2. Creates a staging table for this summary table 
//         3. Applies contents of staging table to AST
//         4. Restores the data in a summary table 
//
// SQL STATEMENTS USED:
//         CREATE SUMMARY TABLE
//         DROP
//         INSERT
//         REFRESH
//         SET INTEGRITY
//         FETCH
//         COMMIT 
//
// Classes used from Util.java are:
//        Db
//        SqljException
//
// OUTPUT FILE: TbAST.out (available in the online documentation)
// Output will vary depending on the JDBC driver connectivity used.
//**************************************************************************
//
// For more information on the sample programs, see the README file.
//
// For information on developing SQLJ applications, see the Application
// Development Guide.
//
// For information on using SQL statements, see the SQL Reference.
//
// For the latest information on programming, compiling, and running DB2
// applications, visit the DB2 application development website at
//     http://www.software.ibm.com/data/db2/udb/ad
//***************************************************************************

import java.lang.*;
import java.sql.*;
import sqlj.runtime.*;
import sqlj.runtime.ref.*;

#sql iterator TbAST_Cursor0(int, int, int);

class TbAST
{
  public static void main(String argv[])
  {
    DefaultContext ctx = null;
    
    try
    {
      Db db = new Db(argv);

      System.out.println();
      System.out.println(
        "THIS SAMPLE SHOWS THE USAGE OF STAGING TABLE TO UPDATE \n" + 
        "REFRESH DEFERRED AST AND RESTORE DATA IN A SUMMARY TABLE \n" +
        "\n-----------------------------------------------------------\n");

      // connect to the 'sample' database
      ctx = db.getDefaultContext();

      // create a base table, summary table, staging table 
      createStagingTable();

      // to show the propagation of changes of base table to
      // summary tables through the staging table 
      System.out.println(
        "\n-----------------------------------------------------------\n" +
        "To show the propagation of changes from base table to \n" +
        "summary tables through the staging table: \n" );
      propagateStagingToAst( ctx.getConnection() );
    
      // to show restoring of data in a summary table 
      System.out.println(
        "\n------------------------------------------------------------ \n" +
        "To show restoring of data in a summary table");
      restoreSummaryTable( ctx.getConnection() );
  
      // drop the created tables
      System.out.println(
        "\n------------------------------------------------------------ \n" +
        "Drop the created tables");
      dropTables();
 
      // disconnect from 'sample' database
      db.disconnect();
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // main

  // Creates base table, summary table and staging table 
  static void createStagingTable()
  {
    try
    {          
      //create base table
      System.out.println(
        "\nUSE THE SQL STATEMENT: \n" +
        "  CREATE TABLE \n" +
        "To create base table, summary table, staging table\n\n" +
        "\nCreating the base table t\n" +
        "\n  CREATE TABLE t \n" +
        "    (c1 SMALLINT NOT NULL,\n" +
        "     c2 SMALLINT NOT NULL, \n" +
        "     c3 SMALLINT, \n" +
        "     c4 SMALLINT)");
      
      #sql {CREATE TABLE t
              (c1 SMALLINT NOT NULL, 
               c2 SMALLINT NOT NULL, 
               c3 SMALLINT, 
               c4 SMALLINT)};

      System.out.println("\n  COMMIT");
      #sql {COMMIT};
      
      // create summary table
      System.out.println(
        "\nCreating summary table d_ast \n" +
        "\n  CREATE SUMMARY TABLE d_ast AS\n" + 
        "    (SELECT c1, c2, COUNT(*) AS count \n" +
        "      FROM t \n" +
        "      GROUP BY c1, c2) \n" +
        "    DATA INITIALLY DEFERRED \n" +
        "    REFRESH DEFERRED ");
       
      #sql {CREATE SUMMARY TABLE d_ast AS 
              (SELECT c1, c2, COUNT(*) AS count
                FROM t 
                GROUP BY c1, c2)
              DATA INITIALLY DEFERRED
              REFRESH DEFERRED};

      System.out.println("\n  COMMIT");
      #sql {COMMIT};
                         
      // create staging table
      System.out.println("\nCreating the staging table g \n" + 
        "\n  CREATE TABLE g FOR d_ast PROPAGATE IMMEDIATE");
      #sql {CREATE TABLE g FOR d_ast PROPAGATE IMMEDIATE};

      System.out.println("\n  COMMIT");
      #sql {COMMIT};
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // createStagingTable
  
  // Show how to propagate the changes from base table to
  // summary tables through the staging table
  static void propagateStagingToAst(Connection con)
  {
    try
    {  
      Statement stmt = con.createStatement();
          
      System.out.println(
        "Bring staging table out of pending state \n"+
        "  SET INTEGRITY FOR g IMMEDIATE CHECKED");
      stmt.executeUpdate("SET INTEGRITY FOR G IMMEDIATE CHECKED");
      #sql {COMMIT};
                   
      System.out.println(
        "\nRefresh summary table, get it out of pending state. \n" + 
        "  REFRESH TABLE d_ast NOT INCREMENTAL\n");
      #sql {REFRESH TABLE d_ast NOT INCREMENTAL};  
      #sql {COMMIT};
            
      System.out.println(
        "\nInsert data into base table T\n" +
        "  INSERT INTO t VALUES(1,1,1,1), \n" +
        "                      (2,2,2,2), \n" +
        "                      (1,1,1,1), \n" +
        "                      (3,3,3,3)");
      #sql {INSERT INTO t VALUES (1,1,1,1), 
                                 (2,2,2,2), 
                                 (1,1,1,1), 
                                 (3,3,3,3) };
      #sql {COMMIT};
      
      System.out.println(
        "\nDisplay the contents of staging table g.\n" + 
        "The Staging table contains incremental changes to base table."); 
      displayTable("g");
 
      System.out.println(
        "\n\nRefresh the summary table \n" +
        "  REFRESH TABLE d_ast INCREMENTAL\n");
      #sql {REFRESH TABLE d_ast INCREMENTAL};
      #sql {COMMIT};
      
      System.out.println(
        "Display the contents of staging table g \n" +
        "   NOTE: The staging table is pruned after AST is \n" +
        "         refreshed. The contents are propagated to AST \n" +
        "         from the staging table");
      displayTable("g");

      System.out.println(
        "\nDisplay the contents of AST\n"  +
        "Summary table has the changes propagated from staging table");
      displayTable("d_ast");
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // propagateStagingToAst
  
  // Shows how to restore the data in a summary table 
  static void restoreSummaryTable(Connection con)
  {
    try
    { 
      Statement stmt = con.createStatement();
     
      System.out.println(
        "\nBlock all modifications to the summary table \n" +
        "by setting the integrity to off \n" +
        "  (g is placed in pending and g.CC=N) \n" +      
        "\n  SET INTEGRITY FOR g OFF");
      stmt.executeUpdate("SET INTEGRITY FOR g OFF");    
      #sql {COMMIT};
                
      System.out.println(
        "\nExport the query definition in summary table and load \n" +
        "directly back to the summary table.\n" +
        "  (d_ast and g both in pending \n" + 
        "\n  SET INTEGRITY FOR d_ast OFF CASCADE IMMEDIATE\n");
      stmt.executeUpdate("SET INTEGRITY FOR d_ast OFF CASCADE IMMEDIATE");
      #sql {COMMIT};
     
      System.out.println(
        "Prune staging table and place it in normal state\n" +
        "  (g.CC=F)\n" + 
        "\n  SET INTEGRITY FOR g IMMEDIATE CHECKED PRUNE\n");
      stmt.executeUpdate("SET INTEGRITY FOR g IMMEDIATE CHECKED PRUNE");
      #sql {COMMIT}; 
      
      System.out.println(
        "Changing staging table state to U \n"  +
        "  (g.CC to U)\n" +
        "\n  SET INTEGRITY FOR g STAGING IMMEDIATE UNCHECKED\n");
      stmt.executeUpdate("SET INTEGRITY FOR g STAGING IMMEDIATE UNCHECKED");
      #sql {COMMIT};
      
      System.out.println(
        "\nPlace d_ast in normal and d_ast.CC to U \n" + 
        "\n  SET INTEGRITY FOR d_ast MATERIALIZED QUERY" +
        " IMMEDIATE UNCHECKED\n" );
      stmt.executeUpdate(
        "SET INTEGRITY FOR d_ast MATERIALIZED QUERY IMMEDIATE UNCHECKED");
      #sql {COMMIT};

      stmt.close();
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // restoreSummaryTable
  
  // Displays the contents of the table being passed as the argument
  static void displayTable(String tableName)
  {
    TbAST_Cursor0 cur0;
    int c1 = 0;
    int c2 = 0;
    int count = 0;
      
    try
    {           
      if (tableName.equals("g"))
      {
        #sql cur0 = {SELECT c1, c2, count FROM g};
        System.out.println(
          "\n  SELECT c1, c2, count FROM g\n" +
          "\n  C1    C2    COUNT " +
          "\n  ------------------");
      }
      else 
      {
        #sql cur0 = {SELECT c1, c2, count FROM d_ast};
        System.out.println(
          "\n  SELECT c1, c2, count FROM d_ast\n" +
          "\n  C1    C2    COUNT " +
          "\n  ------------------");
      }
           
      // retrieve and display the result from the SELECT statement
      #sql {FETCH :cur0 INTO :c1, :c2, :count};
      
      while (!cur0.endFetch())
      {                
        System.out.println("   " + c1 + "    " + c2 + "    " + count );
        #sql {FETCH :cur0 INTO :c1, :c2, :count};
      }
    }  
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // displayTable
  
  // Drops the staging table, summary table and base table
  static void dropTables()
  { 
    try
    {      
      System.out.println(
        "Dropping a base table implicitly drops summary table defined \n"  +
        "on it which in turn cascades to dropping its staging table. \n" +
        "\nUSE THE SQL STATEMENT:\n" +
        "  DROP TABLE \n" + 
        "To drop a table \n" +
        "\n  DROP TABLE t");
     
      #sql {DROP TABLE t};

      System.out.println("\n  COMMIT");
      #sql {COMMIT};
    }
    catch (Exception e)
    {
      SqljException sqljExc = new SqljException(e);
      sqljExc.handle();
    }
  } // dropTables
} // TbAST
